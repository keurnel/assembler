package keurnel_asm

const (
	INSTRUCTION_GROUP_TYPE_DIRECTIVE = 0
	INSTRUCTION_GROUP_TYPE_LABEL     = 1
)

type Parser struct {
	lexer  *Lexer
	groups map[string]InstructionGroup
}

// InstructionGroup - represents a group of related instructions in the assembly code. The instructions
// are grouped together by a label or directive.
type InstructionGroup struct {
	Type         int // Directive or Label
	Identifier   string
	Instructions []Instruction
}

// Instruction - represents a single assembly instruction, including the mnemonic and its operands.
type Instruction struct {
	Mnemonic string
	Operands []string
}

// ParserNew - returns a new instance of the Parser
func ParserNew(lexer *Lexer) *Parser {
	return &Parser{
		lexer:  lexer,
		groups: make(map[string]InstructionGroup),
	}
}

// Groups - returns the parsed instruction groups
func (p *Parser) Groups() map[string]InstructionGroup {
	return p.groups
}

// Parse - processes the tokens generated by the lexer and constructs an intermediate representation
// of the assembly code that can be used for further analysis and code generation.
func (p *Parser) Parse() {

	for _, token := range p.lexer.Tokens() {

		// When hitting directive or label, create a new instruction group and add it to the groups map.
		if token.Type == DIRECTIVE || token.Type == LABEL {
			groupType := INSTRUCTION_GROUP_TYPE_LABEL
			if token.Type == DIRECTIVE {
				groupType = INSTRUCTION_GROUP_TYPE_DIRECTIVE
			}

			p.groups[token.Literal] = InstructionGroup{
				Type:         groupType,
				Identifier:   token.Literal,
				Instructions: []Instruction{},
			}
			group := p.groups[token.Literal]

			// Add instructions until `ret` is encountered, which indicates the end of the instruction group.
			for _, instrToken := range p.lexer.Tokens() {
				if instrToken.Type == INSTRUCTION {
					instruction := Instruction{
						Mnemonic: instrToken.Literal,
						Operands: []string{}, // TODO: Parse operands from the instruction token
					}

					// Add operands for each instruction
					//
					operandIndex := p.lexer.TokenIndex(instrToken) + 1
					for operandIndex < len(p.lexer.Tokens()) {
						operandToken := p.lexer.Tokens()[operandIndex]
						if operandToken.Type == OPERAND {
							instruction.Operands = append(instruction.Operands, operandToken.Literal)
							operandIndex++
						} else {
							break
						}
					}

					group.Instructions = append(group.Instructions, instruction)
					p.groups[token.Literal] = group

					if instrToken.Literal == "ret" {
						break
					}
				}
			}
		}

	}

}

// TokenIndex returns the index of the given token in the tokens slice
func (l *Lexer) TokenIndex(token Token) int {
	for i, t := range l.tokens {
		if t.Type == token.Type && t.Literal == token.Literal {
			return i
		}
	}
	return -1
}
