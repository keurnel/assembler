package keurnel_asm

const (
	INSTRUCTION_GROUP_TYPE_DIRECTIVE = 0
	INSTRUCTION_GROUP_TYPE_LABEL     = 1
	INSTRUCTION_GROUP_TYPE_GLOBAL    = 2
	INSTRUCTION_GROUP_TYPE_NAMESPACE = 3
)

type Parser struct {
	lexer  *Lexer
	groups map[string]InstructionGroup
}

// InstructionGroup - represents a group of related instructions in the assembly code. The instructions
// are grouped together by a label or directive.
type InstructionGroup struct {
	Type         int // Directive or Label
	Identifier   string
	Instructions []Instruction
}

// Instruction - represents a single assembly instruction, including the mnemonic and its operands.
type Instruction struct {
	Mnemonic string
	Operands []string
}

// ParserNew - returns a new instance of the Parser
func ParserNew(lexer *Lexer) *Parser {
	return &Parser{
		lexer:  lexer,
		groups: make(map[string]InstructionGroup),
	}
}

// Groups - returns the parsed instruction groups
func (p *Parser) Groups() map[string]InstructionGroup {
	return p.groups
}

// Parse - processes the tokens generated by the lexer and constructs an intermediate representation
// of the assembly code that can be used for further analysis and code generation.
func (p *Parser) Parse() {
	tokens := p.lexer.Tokens()
	i := 0

	// Initialize global group for instructions not belonging to any label/directive
	globalInstructions := []Instruction{}

	for i < len(tokens) {
		token := tokens[i]

		// Handle namespace declarations
		if token.Type == NAMESPACE {
			group := InstructionGroup{
				Type:         INSTRUCTION_GROUP_TYPE_NAMESPACE,
				Identifier:   token.Literal,
				Instructions: []Instruction{},
			}
			p.groups["namespace:"+token.Literal] = group
			i++
			continue
		}

		// When hitting directive or label, create a new instruction group and add it to the groups map.
		if token.Type == DIRECTIVE || token.Type == LABEL {
			groupType := INSTRUCTION_GROUP_TYPE_LABEL
			if token.Type == DIRECTIVE {
				groupType = INSTRUCTION_GROUP_TYPE_DIRECTIVE
			}

			group := InstructionGroup{
				Type:         groupType,
				Identifier:   token.Literal,
				Instructions: []Instruction{},
			}

			i++ // Move past the label/directive token

			// Add instructions until `ret` is encountered or another label/directive is found
			for i < len(tokens) {
				currentToken := tokens[i]

				// Stop if we hit another label or directive
				if currentToken.Type == DIRECTIVE || currentToken.Type == LABEL {
					break
				}

				// Stop if we hit EOF
				if currentToken.Type == EOF {
					break
				}

				// Process instruction
				if currentToken.Type == INSTRUCTION {
					instruction := Instruction{
						Mnemonic: currentToken.Literal,
						Operands: []string{},
					}

					i++ // Move past the instruction token

					// Collect all operands for this instruction
					for i < len(tokens) && tokens[i].Type == OPERAND {
						instruction.Operands = append(instruction.Operands, tokens[i].Literal)
						i++
					}

					group.Instructions = append(group.Instructions, instruction)

					// Stop at `ret` instruction and move to next token
					if instruction.Mnemonic == "ret" {
						break
					}
				} else {
					// Skip any other token types (ILLEGAL, etc.)
					i++
				}
			}

			p.groups[token.Literal] = group
		} else if token.Type == INSTRUCTION {
			// This is a global instruction (not in any label/directive)
			instruction := Instruction{
				Mnemonic: token.Literal,
				Operands: []string{},
			}

			i++ // Move past the instruction token

			// Collect all operands for this instruction
			for i < len(tokens) && tokens[i].Type == OPERAND {
				instruction.Operands = append(instruction.Operands, tokens[i].Literal)
				i++
			}

			globalInstructions = append(globalInstructions, instruction)
		} else {
			i++
		}
	}

	// Add global instructions group if any exist
	if len(globalInstructions) > 0 {
		p.groups["global"] = InstructionGroup{
			Type:         INSTRUCTION_GROUP_TYPE_GLOBAL,
			Identifier:   "global",
			Instructions: globalInstructions,
		}
	}
}
