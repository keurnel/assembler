package keurnel_asm

const (
	INSTRUCTION_GROUP_TYPE_DIRECTIVE = 0
	INSTRUCTION_GROUP_TYPE_LABEL     = 1
	INSTRUCTION_GROUP_TYPE_GLOBAL    = 2
	INSTRUCTION_GROUP_TYPE_NAMESPACE = 3
)

type Parser struct {
	lexer  *Lexer
	groups map[string]InstructionGroup
}

// InstructionGroup - represents a group of related instructions in the assembly code. The instructions
// are grouped together by a label or directive.
type InstructionGroup struct {
	Type         int                         // Directive, Label, Global, or Namespace
	Identifier   string                      // Name of the group
	Instructions []Instruction               // Instructions in this group
	Children     map[string]InstructionGroup // Child groups (for namespaces)
}

// Instruction - represents a single assembly instruction, including the mnemonic and its operands.
type Instruction struct {
	Mnemonic string
	Operands []string
}

// ParserNew - returns a new instance of the Parser
func ParserNew(lexer *Lexer) *Parser {
	return &Parser{
		lexer:  lexer,
		groups: make(map[string]InstructionGroup),
	}
}

// Groups - returns the parsed instruction groups
func (p *Parser) Groups() map[string]InstructionGroup {
	return p.groups
}

// GetGroup - returns a specific instruction group by name
func (p *Parser) GetGroup(name string) (InstructionGroup, bool) {
	group, exists := p.groups[name]
	return group, exists
}

// GetChild - returns a child group from a parent group
func (g *InstructionGroup) GetChild(name string) (InstructionGroup, bool) {
	if g.Children == nil {
		return InstructionGroup{}, false
	}
	child, exists := g.Children[name]
	return child, exists
}

// HasChildren - returns true if the group has child groups
func (g *InstructionGroup) HasChildren() bool {
	return g.Children != nil && len(g.Children) > 0
}

// Parse - processes the tokens generated by the lexer and constructs an intermediate representation
// of the assembly code that can be used for further analysis and code generation.
func (p *Parser) Parse() {
	tokens := p.lexer.Tokens()
	i := 0

	// Track global instructions per context (top-level or per namespace)
	globalInstructions := []Instruction{}
	namespaceGlobalInstructions := make(map[string][]Instruction)

	// Track current namespace
	var currentNamespace *InstructionGroup = nil

	for i < len(tokens) {
		token := tokens[i]

		// Handle namespace declarations
		if token.Type == NAMESPACE {
			// Save previous namespace's global instructions before switching
			if currentNamespace != nil && len(namespaceGlobalInstructions[currentNamespace.Identifier]) > 0 {
				currentNamespace.Children["global"] = InstructionGroup{
					Type:         INSTRUCTION_GROUP_TYPE_GLOBAL,
					Identifier:   "global",
					Instructions: namespaceGlobalInstructions[currentNamespace.Identifier],
					Children:     make(map[string]InstructionGroup),
				}
				p.groups["namespace:"+currentNamespace.Identifier] = *currentNamespace
			}

			group := InstructionGroup{
				Type:         INSTRUCTION_GROUP_TYPE_NAMESPACE,
				Identifier:   token.Literal,
				Instructions: []Instruction{},
				Children:     make(map[string]InstructionGroup),
			}
			p.groups["namespace:"+token.Literal] = group
			// Set current namespace to this group (we'll update it in the map later)
			currentNamespace = &group
			i++
			continue
		}

		// When hitting directive or label, create a new instruction group and add it to the groups map.
		if token.Type == DIRECTIVE || token.Type == LABEL {
			groupType := INSTRUCTION_GROUP_TYPE_LABEL
			if token.Type == DIRECTIVE {
				groupType = INSTRUCTION_GROUP_TYPE_DIRECTIVE
			}

			group := InstructionGroup{
				Type:         groupType,
				Identifier:   token.Literal,
				Instructions: []Instruction{},
				Children:     make(map[string]InstructionGroup),
			}

			i++ // Move past the label/directive token

			// Add instructions until `ret` is encountered or another label/directive is found
			for i < len(tokens) {
				currentToken := tokens[i]

				// Stop if we hit another label or directive
				if currentToken.Type == DIRECTIVE || currentToken.Type == LABEL {
					break
				}

				// Stop if we hit EOF
				if currentToken.Type == EOF {
					break
				}

				// Stop if we hit a new namespace
				if currentToken.Type == NAMESPACE {
					break
				}

				// Process instruction
				if currentToken.Type == INSTRUCTION {
					instruction := Instruction{
						Mnemonic: currentToken.Literal,
						Operands: []string{},
					}

					i++ // Move past the instruction token

					// Collect all operands for this instruction
					for i < len(tokens) && tokens[i].Type == OPERAND {
						instruction.Operands = append(instruction.Operands, tokens[i].Literal)
						i++
					}

					group.Instructions = append(group.Instructions, instruction)

					// Stop at `ret` instruction and move to next token
					if instruction.Mnemonic == "ret" {
						break
					}
				} else {
					// Skip any other token types (ILLEGAL, etc.)
					i++
				}
			}

			// Add group to current namespace or to top level
			if currentNamespace != nil {
				currentNamespace.Children[token.Literal] = group
				// Update the namespace in the groups map
				p.groups["namespace:"+currentNamespace.Identifier] = *currentNamespace
			} else {
				p.groups[token.Literal] = group
			}
		} else if token.Type == INSTRUCTION {
			// This is a global instruction (not in any label/directive)
			instruction := Instruction{
				Mnemonic: token.Literal,
				Operands: []string{},
			}

			i++ // Move past the instruction token

			// Collect all operands for this instruction
			for i < len(tokens) && tokens[i].Type == OPERAND {
				instruction.Operands = append(instruction.Operands, tokens[i].Literal)
				i++
			}

			// Add to namespace-specific global instructions or top-level global
			if currentNamespace != nil {
				namespaceGlobalInstructions[currentNamespace.Identifier] = append(
					namespaceGlobalInstructions[currentNamespace.Identifier],
					instruction,
				)
			} else {
				globalInstructions = append(globalInstructions, instruction)
			}
		} else {
			i++
		}
	}

	// Add final namespace's global instructions if any exist
	if currentNamespace != nil && len(namespaceGlobalInstructions[currentNamespace.Identifier]) > 0 {
		currentNamespace.Children["global"] = InstructionGroup{
			Type:         INSTRUCTION_GROUP_TYPE_GLOBAL,
			Identifier:   "global",
			Instructions: namespaceGlobalInstructions[currentNamespace.Identifier],
			Children:     make(map[string]InstructionGroup),
		}
		p.groups["namespace:"+currentNamespace.Identifier] = *currentNamespace
	}

	// Add top-level global instructions group if any exist
	if len(globalInstructions) > 0 {
		p.groups["global"] = InstructionGroup{
			Type:         INSTRUCTION_GROUP_TYPE_GLOBAL,
			Identifier:   "global",
			Instructions: globalInstructions,
			Children:     make(map[string]InstructionGroup),
		}
	}
}
